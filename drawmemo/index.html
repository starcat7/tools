<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>HandWrite Z</title>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#111827">
  <style>
    html,body{margin:0;height:100%;background:#0b0f1a;color:#e5e7eb;font-family:system-ui, -apple-system, Segoe UI, Roboto;}
    #topbar{
      position:fixed; inset:0 0 auto 0; height:56px; display:flex; gap:8px; align-items:center;
      padding:8px 12px; background:#111827; border-bottom:1px solid #1f2937; z-index:10;
    }
    select,button,input[type="color"]{
      height:38px; border-radius:12px; border:1px solid #374151; background:#0f172a; color:#e5e7eb;
      padding:0 10px; outline:none;
    }
    button{cursor:pointer}
    button:active{transform:translateY(1px)}
    #canvas{position:fixed; inset:56px 0 0 0; touch-action:none; background:#0b0f1a;}
    .pill{padding:0 14px}
    .spacer{flex:1}
    .hint{font-size:12px; opacity:.7}
  </style>
</head>
<body>
  <div id="topbar">
    <select id="docSelect" title="メモ選択"></select>
    <button id="newDoc" class="pill">＋新規</button>
    <button id="renameDoc" class="pill">名前変更</button>
    <button id="deleteDoc" class="pill">削除</button>
    <div class="spacer"></div>
    <input type="color" id="penColor" value="#00e5ff" title="ペン色">
    <select id="penSize" title="ペン太さ">
      <option value="2">2px</option><option value="4" selected>4px</option>
      <option value="6">6px</option><option value="10">10px</option><option value="16">16px</option>
    </select>
    <button id="eraser" class="pill">消しゴム</button>
    <button id="undo" class="pill">元に戻す</button>
    <button id="redo" class="pill">やり直し</button>
    <button id="resetView" class="pill">表示リセット</button>
    <span class="hint">描く:1本指 / パン&ズーム:2本指（PCはSpace+ドラッグ, Ctrl+ホイール）</span>
  </div>
  <canvas id="canvas"></canvas>

  <script>
  // ---- PWA ----
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js'));
  }

  // ---- IndexedDB (超ミニラッパ) ----
  const DB_NAME = 'handwritez';
  const STORE = 'docs';
  function idb() {
    return new Promise((res, rej)=>{
      const open = indexedDB.open(DB_NAME, 1);
      open.onupgradeneeded = () => open.result.createObjectStore(STORE, {keyPath:'id'});
      open.onsuccess = () => res(open.result);
      open.onerror = () => rej(open.error);
    });
  }
  async function dbGetAll() {
    const db = await idb();
    return new Promise((res, rej)=>{
      const tx = db.transaction(STORE,'readonly');
      const req = tx.objectStore(STORE).getAll();
      req.onsuccess = () => res(req.result || []);
      req.onerror = () => rej(req.error);
    });
  }
  async function dbPut(doc) {
    const db = await idb();
    return new Promise((res, rej)=>{
      const tx = db.transaction(STORE,'readwrite');
      tx.objectStore(STORE).put(doc);
      tx.oncomplete = () => res();
      tx.onerror = () => rej(tx.error);
    });
  }
  async function dbDelete(id) {
    const db = await idb();
    return new Promise((res, rej)=>{
      const tx = db.transaction(STORE,'readwrite');
      tx.objectStore(STORE).delete(id);
      tx.oncomplete = () => res();
      tx.onerror = () => rej(tx.error);
    });
  }

  // ---- ドキュメント状態 ----
  let docs = []; // {id, name, strokes:[Stroke], undoStack:[Stroke], createdAt}
  let currentId = null;

  function newDocName() {
    const base = 'メモ';
    let n=1;
    while (docs.some(d=>d.name === `${base}${n}`)) n++;
    return `${base}${n}`;
  }

  async function createDoc() {
    const doc = { id: crypto.randomUUID(), name: newDocName(), strokes: [], undoStack: [], createdAt: Date.now() };
    docs.push(doc);
    await dbPut(doc);
    refreshDocSelect(doc.id);
  }

  function refreshDocSelect(selectId=currentId) {
    docSelect.innerHTML = '';
    docs.sort((a,b)=>a.createdAt-b.createdAt).forEach(d=>{
      const opt = document.createElement('option');
      opt.value = d.id; opt.textContent = d.name;
      docSelect.appendChild(opt);
    });
    if (docs.length && !docs.some(d=>d.id===selectId)) selectId = docs[0].id;
    docSelect.value = selectId || '';
    currentId = docSelect.value || null;
    redraw();
  }

  function currentDoc(){ return docs.find(d=>d.id===currentId) || null; }

  async function renameCurrent() {
    const doc = currentDoc(); if (!doc) return;
    const name = prompt('新しい名前', doc.name);
    if (!name) return;
    doc.name = name;
    await dbPut(doc); refreshDocSelect(doc.id);
  }

  async function deleteCurrent() {
    const doc = currentDoc(); if (!doc) return;
    if (!confirm(`「${doc.name}」を削除する？`)) return;
    await dbDelete(doc.id);
    docs = docs.filter(d=>d.id!==doc.id);
    currentId = docs[0]?.id || null;
    refreshDocSelect(currentId);
  }

  // ---- 描画エンジン（無限キャンバス） ----
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
  const DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  let W=0, H=0;

  // ビュー変換（ワールド→画面）
  let scale = 1.0;
  let offsetX = 0;
  let offsetY = 0;

  function resize() {
    const r = canvas.getBoundingClientRect();
    W = Math.floor(r.width * DPR);
    H = Math.floor(r.height * DPR);
    canvas.width = W; canvas.height = H;
    redraw();
  }
  window.addEventListener('resize', resize);

  function toScreen(x,y) { return [ (x*scale + offsetX)*DPR, (y*scale + offsetY)*DPR ]; }
  function toWorld(sx,sy) { return [ (sx/DPR - offsetX)/scale, (sy/DPR - offsetY)/scale ]; }

  function clear() {
    ctx.fillStyle = '#0b0f1a';
    ctx.fillRect(0,0,W,H);
  }

  function drawStroke(stroke) {
    const pts = stroke.points;
    if (pts.length < 2) {
      const [sx,sy] = toScreen(pts[0].x, pts[0].y);
      ctx.fillStyle = stroke.color;
      ctx.beginPath(); ctx.arc(sx,sy, (stroke.width*scale*DPR)/2, 0, Math.PI*2); ctx.fill();
      return;
    }
    ctx.lineJoin='round'; ctx.lineCap='round';
    ctx.strokeStyle = stroke.erase ? '#0b0f1a' : stroke.color;
    ctx.lineWidth = Math.max(1, stroke.width * scale * DPR);
    ctx.beginPath();
    for (let i=0;i<pts.length;i++){
      const [sx,sy] = toScreen(pts[i].x, pts[i].y);
      if (i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
    }
    ctx.stroke();
  }

  function redraw() {
    clear();
    const doc = currentDoc(); if (!doc) return;
    for (const s of doc.strokes) drawStroke(s);
  }

  // ---- 入力（Pointer + マルチタッチ） ----
  let drawing = false;
  let activeStroke = null;
  let pointers = new Map(); // id -> {x,y}
  let lastPinch = null;

  const penColor = document.getElementById('penColor');
  const penSize  = document.getElementById('penSize');
  const eraserBtn = document.getElementById('eraser');
  const undoBtn = document.getElementById('undo');
  const redoBtn = document.getElementById('redo');
  const resetViewBtn = document.getElementById('resetView');
  const docSelect = document.getElementById('docSelect');

  let erasing = false;
  eraserBtn.addEventListener('click', ()=>{ erasing = !erasing; eraserBtn.textContent = erasing ? '消しゴム中' : '消しゴム'; });

  function startStroke(x,y,pressure=0.5){
    const doc = currentDoc(); if (!doc) return;
    activeStroke = {
      id: crypto.randomUUID(),
      color: erasing ? '#0b0f1a' : penColor.value,
      width: parseFloat(penSize.value),
      erase: erasing,
      points: []
    };
    doc.undoStack.length = 0; // 何か描いたらredo消す
    addPoint(x,y,pressure);
  }

  function addPoint(x,y,pressure=0.5){
    if (!activeStroke) return;
    activeStroke.points.push({x,y,p:pressure});
    // 描画を小刻みに反映
    const doc = currentDoc(); if (!doc) return;
    // 最後のストロークだけ描き直す簡易最適化
    redraw();
    drawStroke(activeStroke);
  }

  async function endStroke(){
    const doc = currentDoc(); if (!doc || !activeStroke) return;
    if (activeStroke.points.length>0) {
      doc.strokes.push(activeStroke);
      await dbPut(doc);
    }
    activeStroke = null;
    redraw();
  }

  // ジェスチャ
  function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function mid(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }

  function onPointerDown(e){
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if (pointers.size===1 && !(e.ctrlKey || spaceKey)) {
      const [x,y] = toWorld(e.clientX, e.clientY);
      startStroke(x,y,e.pressure||0.5);
      drawing = true;
    } else if (pointers.size===2){
      lastPinch = { p1:[...pointers.values()][0], p2:[...pointers.values()][1], scale, offsetX, offsetY };
    }
  }
  function onPointerMove(e){
    const prev = pointers.get(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    if (pointers.size===1 && drawing && !spaceKey && !e.ctrlKey){
      const [x,y] = toWorld(e.clientX, e.clientY);
      addPoint(x,y,e.pressure||0.5);
    } else if (pointers.size>=2 || spaceKey || e.ctrlKey){
      // パン・ズーム
      if (pointers.size>=2){
        const vals = [...pointers.values()];
        const a=vals[0], b=vals[1];
        const m0 = mid(lastPinch.p1, lastPinch.p2);
        const m1 = mid(a,b);
        const d0 = distance(lastPinch.p1,lastPinch.p2);
        const d1 = distance(a,b);
        let s = lastPinch.scale * (d1 / Math.max(10,d0));
        s = Math.min(8, Math.max(0.1, s));
        // 中心を保ったまま拡縮
        const [wx0, wy0] = toWorld(m0.x, m0.y);
        scale = s;
        const [sx1, sy1] = [m1.x, m1.y];
        const [wx1, wy1] = [wx0, wy0];
        offsetX = sx1 - wx1*scale;
        offsetY = sy1 - wy1*scale;
        redraw();
      } else if (prev && (spaceKey || e.ctrlKey)){
        // 1本指パン（PC）
        const dx = e.clientX - prev.x;
        const dy = e.clientY - prev.y;
        offsetX += dx;
        offsetY += dy;
        redraw();
      }
    }
  }
  function onPointerUp(e){
    pointers.delete(e.pointerId);
    if (drawing && pointers.size===0){
      drawing = false;
      endStroke();
    }
    if (pointers.size<2) lastPinch = null;
  }

  canvas.addEventListener('pointerdown', onPointerDown);
  canvas.addEventListener('pointermove', onPointerMove);
  canvas.addEventListener('pointerup', onPointerUp);
  canvas.addEventListener('pointercancel', onPointerUp);
  canvas.addEventListener('pointerout', onPointerUp);
  canvas.addEventListener('pointerleave', onPointerUp);

  // ホイールでズーム（Ctrl+ホイール）
  canvas.addEventListener('wheel', (e)=>{
    if (!e.ctrlKey) return; // ピンチズームと同じ感覚（Chrome標準）
    e.preventDefault();
    const delta = -e.deltaY;
    const zoom = Math.exp(delta * 0.0015);
    const mx = e.clientX, my = e.clientY;
    const [wx, wy] = toWorld(mx, my);
    scale = Math.min(8, Math.max(0.1, scale * zoom));
    offsetX = mx - wx*scale;
    offsetY = my - wy*scale;
    redraw();
  }, {passive:false});

  // Spaceでパン
  let spaceKey = false;
  window.addEventListener('keydown', e=>{ if (e.code==='Space') spaceKey=true; });
  window.addEventListener('keyup', e=>{ if (e.code==='Space') spaceKey=false; });

  // 操作系
  undoBtn.addEventListener('click', async()=>{
    const doc = currentDoc(); if (!doc || !doc.strokes.length) return;
    const s = doc.strokes.pop(); doc.undoStack.push(s); await dbPut(doc); redraw();
  });
  redoBtn.addEventListener('click', async()=>{
    const doc = currentDoc(); if (!doc || !doc.undoStack.length) return;
    const s = doc.undoStack.pop(); doc.strokes.push(s); await dbPut(doc); redraw();
  });
  resetViewBtn.addEventListener('click', ()=>{ scale=1; offsetX=0; offsetY=0; redraw(); });

  docSelect.addEventListener('change', ()=>{ currentId = docSelect.value; redraw(); });
  newDoc.addEventListener('click', createDoc);
  renameDoc.addEventListener('click', renameCurrent);
  deleteDoc.addEventListener('click', deleteCurrent);

  // 初期ロード
  (async function init(){
    // 画面サイズ反映
    const fit = ()=>{ canvas.style.width='100%'; canvas.style.height='calc(100% - 56px)'; resize(); };
    fit(); new ResizeObserver(fit).observe(canvas);

    docs = await dbGetAll();
    if (docs.length===0) await createDoc(); else refreshDocSelect(docs[0].id);
  })();
  </script>
</body>
</html>
